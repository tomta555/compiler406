package th.ac.cmu.cpe.cpe406.parse;

import th.ac.cmu.cpe.cpe406.ast.*;
import th.ac.cmu.cpe.cpe406.lex.*;
import th.ac.cmu.cpe.cpe406.util.ErrorInfo;
import th.ac.cmu.cpe.cpe406.util.ErrorQueue;
import th.ac.cmu.cpe.cpe406.util.Position;

import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.Symbol;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

parser Grm {:

    protected Lexer lexer;
    protected ErrorQueue eq;
    protected PrintWriter parsedpw;

    protected boolean parseErrorReported;

    public Grm(Lexer lexer, ErrorQueue eq, PrintWriter parsedpw) {
        this(null, new ComplexSymbolFactory());
        this.lexer = lexer;
        this.eq = eq;
        this.parsedpw = parsedpw;
    }

    @Override
    public void syntax_error(Symbol current) {
        Token token = (Token) current.value;
        Position p = token.getPosition();
        String msg = "Syntax error: unexpected " + current.value + ".";
        if (!(token instanceof LexErrorToken))
            report_error(msg, p);
        syntax_error_file(msg, p);
    }

    protected void syntax_error_file(String msg, Position p) {
        if (parsedpw != null && !parseErrorReported) {
            try (BufferedWriter bw = new BufferedWriter(parsedpw);) {
                bw.write(p.line() + ":" + p.column() + " error:" + msg
                        + "\n");
            }
            catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            parseErrorReported = true;
        }
    }

  /**
   * Override the default CUP routine.
   */
  @Override
  public void report_error(String message, Object info) {
    if (info instanceof Position)
    eq.enqueue(ErrorInfo.SYNTAX_ERROR, message, (Position) info);
    else
    eq.enqueue(ErrorInfo.SYNTAX_ERROR, message);
  }

    /**
     * The standard scanning routine for use in the CUP "scan with"
     * declaration. Should read:
     *   scan with { : return nextSymbol(); : }
     */
    public Symbol nextSymbol() throws java.io.IOException {
        Token t = lexer.nextToken();
        if (t.symbol() == sym.error) {
            syntax_error_file("lexical error", t.getPosition());
        }

        return getSymbolFactory().newSymbol(t.toString(), t.symbol(), t);
    }

    /**
     * Return the source position of the Node.
     */
    public Position pos(Node n) {
        if (n == null) {
            return null;
        }
        return n.position();
    }

    /**
     * Return the position of the Token.
     */
    public Position pos(Token t) {
        if (t == null) return null;
        return t.getPosition();
    }

    /**
     * Return the source position of the first element in the list to the
     * last element in the list.
     */
    public Position pos(List<?> l) {
        if (l == null || l.isEmpty()) {
            return null;
        }

        return pos(l.get(0), l.get(l.size() - 1));
    }

    public Position pos(Object first, Object last) {
        return pos(first, last, first);
    }

    public Position pos(Object first, Object last, Object noEndDefault) {
        Position fpos = posForObject(first);
        Position epos = posForObject(last);

        if (fpos != null && epos != null) {
            if (epos.endColumn() != Position.END_UNUSED) {
                return new Position(fpos, epos);
            }

            // the end line and column are not being used in this extension.
            // so return the default for that case.
            return posForObject(noEndDefault);
        }
        if (epos == null) {
            return posForObject(noEndDefault);
        }
        return null;

    }

    protected Position posForObject(Object o) {
        if (o instanceof Node) {
            return pos((Node) o);
        }
        else if (o instanceof Token) {
            return pos((Token) o);
        }
        else if (o instanceof List) {
            return pos((List<?>) o);
        }
        else {
            return null;
        }
    }

    protected Id id(Identifier id) {
        return new Id_c(pos(id), id.getIdentifier());
    }
:};

scan with {: return nextSymbol(); :};

terminal Token INT, BOOLEAN;
terminal Token OR, AND;
terminal Token EQEQ, NOTEQ;
terminal Token LT, LTEQ, GT, GTEQ;
terminal Token PLUS, MINUS;
terminal Token MULT, DIV, MOD;
terminal Token POW;
terminal Token NOT;
terminal Token EQ;
terminal Token LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
terminal Token IF, ELSE; // if_then_statement, if_then_else_statement
terminal Token WHILE; // while_statement, do_statement
terminal Token RETURN;
terminal Token LENGTH;

terminal Identifier IDENTIFIER;

terminal IntegerLiteral INTEGER_LITERAL, INTEGER_LITERAL_BD;
terminal CharacterLiteral CHARACTER_LITERAL;
terminal BooleanLiteral BOOLEAN_LITERAL;
terminal StringLiteral STRING_LITERAL;

terminal Token COLON, SEMICOLON, COMMA;


nonterminal Program program;
nonterminal LocalDecl var_decl;

nonterminal TypeNode type;
nonterminal TypeNode primitive_type;

nonterminal List<Stmt> stmt_list_opt, stmt_list;
nonterminal semicolon_opt;
nonterminal Stmt stmt, stmt_no_short_if, statement_without_trailing_substatement;
nonterminal Empty empty_statement;
nonterminal Return return_statement;
nonterminal Block block;
nonterminal List<Stmt> block_statements_opt, block_statements;
nonterminal List<Stmt> block_statement;
/*nonterminal List<LocalDecl> local_variable_declaration_statement; */
nonterminal Stmt var_decl_stmt;
nonterminal TypeNode var_decl_type;
nonterminal Stmt assignment_stmt;
nonterminal Stmt if_then_stmt, if_then_stmt_no_paren, if_then_else_stmt, if_then_else_statement_no_short_if;
nonterminal Expr primary, expr;
nonterminal Variable lvalue;
nonterminal List<Variable> left_id;
nonterminal List<Expr> right_expr;
nonterminal Expr logical_or_expr, logical_and_expr;
nonterminal Expr equality_expr, comparison_expr;
nonterminal Expr add_sub_expr, mul_div_expr, expo_expr;
nonterminal Expr neg_expr;
nonterminal Stmt while_stmt;


/* Precedences */
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left OR, AND;
precedence left EQEQ, NOTEQ;
precedence left LT, LTEQ, GT, GTEQ;
precedence right POW;

start with program;

program ::=
    stmt_list_opt:stmts {:
        RESULT = new Program_c(parser.pos(stmts), lexer.file(), stmts);
    :}
;

var_decl ::=
    IDENTIFIER:id COLON type:type {:
        RESULT = new LocalDecl_c(parser.pos(id, type), parser.id(id), type);
    :}
;

type ::=
    primitive_type:type {:
        RESULT = type;
    :}
;

primitive_type ::=
    INT:i {:
        RESULT = new PrimitiveTypeNode_c(parser.pos(i), PrimitiveTypeNode.Kind.INT);
    :}
    | BOOLEAN:b {:
		RESULT = new PrimitiveTypeNode_c(parser.pos(b), PrimitiveTypeNode.Kind.BOOL);
	:}
;

stmt_list_opt ::=
    /* empty */ {:
        RESULT = Collections.emptyList();
    :}
    | stmt_list:l {:
        RESULT = l;
    :}
;

stmt_list ::=
    stmt:s {:
        List<Stmt> l = new LinkedList<>();
        l.add(s);
        RESULT = l;
    :}
    | stmt_list:l stmt:s {:
        l.add(s);
        RESULT = l;
    :}
;

stmt ::=
	statement_without_trailing_substatement:a {:
		RESULT = a;
	:}
    | var_decl_stmt:d SEMICOLON {:
        RESULT = d;
    :}
    | if_then_stmt:a {:
		RESULT = a;
	:}
	| if_then_else_stmt:a {:
		RESULT = a;
	:}
	| while_stmt:w {:
		RESULT = w;
	:}
	| error SEMICOLON:a
            {: RESULT = new Empty_c(parser.pos(a)); 
	:}	
;

block ::=
                    // Block
	LBRACE:n block_statements_opt:a RBRACE:d {:
 		RESULT = new Block_c(parser.pos(n, d), a); 
	:}
;

block_statements_opt ::=
                    // List of Stmt
    {: RESULT = new LinkedList<>(); :}
    | block_statements:a {: 
		RESULT = a; 
	:}
    | error {:
 		RESULT = Collections.<Stmt> emptyList(); 
	:}
;

block_statements ::=
                    // List of Stmt
    block_statement:a {: 
		List<Stmt> l = new LinkedList<>();
        l.addAll(a);
        RESULT = l; 
	:}
    | block_statements:a block_statement:b {: 
		RESULT = a;
        a.addAll(b); 
	:}
;

block_statement ::=
                    // List of Stmt
    /*local_variable_declaration_statement:a {:
		RESULT = new LinkedList<Stmt>(a); 
	:}*/
    stmt:a {: 
		List<Stmt> l = new LinkedList<>();
        l.add(a);
        RESULT = l; 
	:}
;

/*local_variable_declaration_statement ::=
                    // List of LocalDecl
	var_decl_stmt:a SEMICOLON {: 
		RESULT = a; 
	:}
;*/

if_then_stmt ::= 
	IF:n LPAREN expr:e RPAREN stmt:s {:
		RESULT = new If_c(parser.pos(n, s), e, s);
	:}  
  /*| if_then_stmt_no_paren:a {:
		RESULT = a; 
	:} */
;

/*if_then_stmt_no_paren ::=
	IF:n expr:e stmt:s {:
		RESULT = new If_c(parser.pos(n, s), e, s);
	:}
;*/

if_then_else_stmt ::= 
	IF:n LPAREN expr:a RPAREN stmt_no_short_if:b ELSE stmt:c {:
		RESULT = new If_c(parser.pos(n, c), a, b, c);
	:}
;
stmt_no_short_if ::=
	if_then_else_statement_no_short_if:a {:
		RESULT = a; 
	:}
	|statement_without_trailing_substatement:a {:
		RESULT = a; 
	:}
;

if_then_else_statement_no_short_if ::=
	IF:n LPAREN expr:a RPAREN stmt_no_short_if:b ELSE stmt_no_short_if:c {: 
		RESULT = new If_c(parser.pos(n, c), a, b, c); 
	:}
;
statement_without_trailing_substatement ::=
	block:a {: 
		RESULT = a; 
	:} 
	| empty_statement:a {: 
		RESULT = a; 
	:}
	| assignment_stmt:a SEMICOLON {:
        RESULT = a;
    :}
;

while_stmt ::=
	WHILE:n expr:e stmt:s {:
		RESULT = new While_c(parser.pos(n,e),e,s);
	:}	
	/*|WHILE:n LPAREN expr:e RPAREN stmt:s{:
		RESULT = new While_c(parser.pos(n,e),e,s);
	:}*/
	
;

empty_statement ::=
                    // Empty
	SEMICOLON:a {: 
		RESULT = new Empty_c(parser.pos(a)); 
	:}
;

/*return_statement ::=
                    // Return
        RETURN:n expression_opt:a SEMICOLON:d
            {: RESULT = parser.nf.Return(parser.pos(n, d), a); :}
;*/
    
var_decl_stmt ::=
    var_decl:decl {:
        RESULT = decl;
    :}
;

var_decl_type ::=
    primitive_type:type {:
        RESULT = type;
    :}
;

assignment_stmt ::=
	left_id:l EQ right_expr:r {:
        RESULT = new Assign_c(parser.pos(l, r), l, r);
    :}    
;

left_id ::=
	lvalue:l {:
		List<Variable> id_list = new LinkedList<>();
		id_list.add(l);
		RESULT = id_list;
	:}
	| lvalue:l COMMA left_id:r {:
        r.add(l);
        RESULT = r;
	:}
;

right_expr ::=
	expr:e {:
		List<Expr> expr_list = new LinkedList<>();
		expr_list.add(e);
		RESULT = expr_list;
	:}
	| expr:l COMMA right_expr:r {:
        r.add(l);
        RESULT = r;
	:}
;

lvalue ::=
    IDENTIFIER:id {:
        RESULT = new Variable_c(parser.pos(id), parser.id(id));
    :}
;

expr ::=
	logical_or_expr:e {:
		RESULT = e;
	:}
;

logical_or_expr ::= 
	logical_or_expr:l OR logical_and_expr:r {:
		RESULT = new Logical_OR_c(parser.pos(l, r), l, r);
	:}
	|logical_and_expr:e {:
		RESULT = e;
	:}
;

logical_and_expr ::=
	logical_and_expr:l AND logical_and_expr:r {:
		RESULT = new Logical_AND_c(parser.pos(l, r), l, r);
	:}
	|equality_expr:e {:
		RESULT = e;	
	:}
;

equality_expr ::=
	equality_expr:l EQEQ comparison_expr:r {:
		RESULT = new Equal_c(parser.pos(l, r), l, r);
	:}
	|equality_expr:l NOTEQ comparison_expr:r {:
		RESULT = new Not_Equal_c(parser.pos(l, r), l, r);
	:}
	|comparison_expr:e {:
		RESULT = e; 
	:}
;

comparison_expr ::= 
	comparison_expr:l LT add_sub_expr:r {:
		RESULT = new Less_Than_c(parser.pos(l, r), l, r);
	:}
	|comparison_expr:l LTEQ add_sub_expr:r {:
		RESULT = new Less_Than_Equal_c(parser.pos(l, r), l, r);
	:} 
	|comparison_expr:l GT add_sub_expr:r {:
		RESULT = new Greater_Than_c(parser.pos(l, r), l, r);
	:}
	|comparison_expr:l GTEQ add_sub_expr:r {:
		RESULT = new Greater_Than_Equal_c(parser.pos(l, r), l, r);
	:} 
	|add_sub_expr:e {:
		RESULT = e;
	:} 
;

add_sub_expr ::=
	add_sub_expr:l PLUS mul_div_expr:r {:
		RESULT = new Add_c(parser.pos(l, r), l, r);
	:}
	|add_sub_expr:l MINUS mul_div_expr:r {:
		RESULT = new Sub_c(parser.pos(l, r), l, r);
	:}
	|mul_div_expr:e {:
		RESULT = e;
	:}
;

mul_div_expr ::= 
	mul_div_expr:l MULT expo_expr:r {:
		RESULT = new Mul_c(parser.pos(l, r), l, r);
	:}
	|mul_div_expr:l DIV expo_expr:r {:
		RESULT = new Div_c(parser.pos(l, r), l, r);
	:}
	|mul_div_expr:l MOD expo_expr:r {:
		RESULT = new Mod_c(parser.pos(l, r), l, r);
	:}
	|expo_expr:e {:
		RESULT = e;
	:}
;

expo_expr ::=
	expo_expr:l POW neg_expr:r {:
		RESULT = new Pow_c(parser.pos(l, r), l, r);
	:}
	|neg_expr:e {:
		RESULT = e;
	:}
;

neg_expr ::= 
	MINUS:m neg_expr:r {:
		RESULT = new Integer_Neg_c(parser.pos(m, r), r);
	:}
	|NOT:n neg_expr:r {:
		RESULT = new Boolean_Neg_c(parser.pos(n, r), r);
	:}
	|IDENTIFIER:id {:
        RESULT = new Variable_c(parser.pos(id), parser.id(id));
    :}
    |INTEGER_LITERAL:a {:
        RESULT = new IntLit_c(parser.pos(a), a.getValue().intValue());
    :}
    |BOOLEAN_LITERAL:a {: 
		RESULT = new Boolean_Lit_c(parser.pos(a), a.getValue().booleanValue()); 
	:}
    |LPAREN expr:e RPAREN {:
		RESULT = e;
	:}
;

	